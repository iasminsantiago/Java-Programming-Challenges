import java.util.*; 
// importa todo o pacote java.util. Usaremos nextLine() para ler entrada e List e ArrayList para guardar os consultores.

abstract class Consultant {           // abstrata, só serve de base para classes-filhas. Não pode ser instanciada, não veremos Consultant var = new Consultant.
    protected String name;            // atributo = variável de classe; 
    protected String role; 
    // Por ser String, os valores de role não serão diretamente armazenados na memória. Vai apontar para um endereço na memória, que aí sim pode conter seu valor.
    // protected - as classes filhas conseguirão acessar name e role, já códigos de fora da classe mãe e filha não conseguem. 

    // Metodo construtor
    /* this.name é o atributo da classe (armazenado no heap).
    name, à direita do '=', é o parâmetro do construtor (armazenado na stack).
    Essa linha atribui, ao atributo do objeto, o valor recebido como argumento na criação do objeto.
    Parâmetro recebe o argumento. Atributo recebe o valor do parâmetro.
    */
    public Consultant(String name, String role) { 
        this.name = name; // quando o construtor é chamado na main, ele atribuirá o nome ao name do objeto. 
        this.role = role;
    }
   

    public String present() {          // é um método que retorna tipo String e junta papel com nome 
        return role + ": " + name;     // ex.: Dev: Iasmin
    }
}

// Aplicando herança

class Developer extends Consultant {     // classe dos desenvolvedores, herda da classe Consultant
    // Construtor da Developer:
    public Developer(String name) {      // receberá só o nome, pois o role mostrado será sempre "Dev" (como print na tela)
        super(name, "Dev");              // super: chama o construtor da classe mãe
    }
}

class Analyst extends Consultant {       // classe dos analistas
    public Analyst(String name) {
        super(name, "Analyst");
    }
}

class Manager extends Consultant {        // classe dos gerentes
    public Manager(String name) {
        super(name, "Manager");
    }
}

public class Main {                                      // o Java sempre começa a executar por aqui
    public static void main(String[] args) {             // método principal
        // vamos criar um leitor de teclado (entrada). Criamos a variável scanner, do tipo Scanner (classe), que aponta pro objeto criado com New Scanner(System.in). 
        Scanner scanner = new Scanner(System.in);        // scanner (esquerda de =)  é variável local de referência
        // scanner é local pois foi declarada dentro do método main e só existe durante a execuçáo desse método, na memória stack. NÃO É OBJETO!   
        // a variável scanner também é uma variável de referência pois guarda uma referência para um objeto String no Heap, criado com new Scanner(System.in). 
        // new cria um objeto no heap, Scanner(...) chama o construtor da classe Scanner e System.in informa o fluxo de entrada padrão: o teclado. System = classe  in = atributo estático.
        // a variável scanner só pode apontar para objetos do tipo Scanner. scanner não é objeto, ele aponta para o objeto. O objeto Scanner (S maiúsculo) é uma instância da classe Scanner.
        // Objeto é criado com new. A variável só guarda a referência.
        String inputLine = scanner.nextLine().trim();    // Lerá a linha inteira digitada. trim tira os espaços antes e depois do texto digitado (String)
        
        /* 
        Onde variável foi declarada	X  Tipo
        Dentro da classe, fora de métodos ->	atributo (instância ou classe)
        Dentro de método	-> variável local
        Variável que guarda endereço de objeto	-> variável de referência

        Stack guarda variáveis em execução, toda variável local vive no stack**
        HEAP guarda objetos. 
        Variáveis primitivas armazenam o valor direto.
        Variáveis de referência armazenam o endereço do objeto.
        **Exceto variáveis de Atributos de instância e de classe, que vivem no HEAP. 
        Os atributos de instância vivem dentro do objeto, por isso estão no heap; os atributos de classe (static) vivem na metaspace (ou área de classe), vivem 
        
        Exemplo de Entrada pelo usuário: Developer Alice;Analyst Bob;Manager Carol
        nextLine() é um método da classe Scanner, é método sendo chamado pelo scanner. 
        Como scanner é uma instância da classe Scanner, pode executar um comportamento dela, sendo ele o nextLine(). 
        Outro exemplo: Pessoa maria = new Pessoa();   maria.andar();
        Tipo nomeVariavel = new Tipo();  
        Pessoa [tipo da variável] maria [nome da variável] = new Pessoa() [objeto criado]
        Obs.: o tipo da variável precisa ser do mesmo do objeto. Por isso, está errado String maria = new Pessoa(); pois Pessoa não é uma String, é um tipo por si só, por ser classe.
        Já o "." é um operador de acesso a membros
        */

        // Aplicando polimorfismo
        List<Consultant> consultantList = new ArrayList<>(); 
        /* Cria uma lista, chamada consultantList, que guarda Consultant. 
        Assim, dentro dela pode existir Developer, Analyst e Manager.
        */

        String[] entries = inputLine.split(";");     // split(;"") = separar em ;
        /* Separar consultores por ";". 
        Se a entrada pelo usuário for: Developer Alice;Analyst Bob;Manager Carol
        ele separará como ["Developer Alice", "Analyst Bob", "Manager Carol"]
        */

        // Percorrendo cada consultor:
        for (String entry : entries) {      // Loop que passa por cada pedaço da lista, de entry até entries
            entry = entry.trim();           // remove espaçso extras no inicio e fim de cada String entry
            if (entry.isEmpty()) continue;  // Se a entrada estiver vazia, pula para o próximo

            String[] parts = entry.split(" ", 2);  // Separando cargo e nome, divide o que tem antes e depois de espaço " " em 2 partes.
            String jobTitle = parts[0];            // Antes do primeiro espaço → cargo.  jobTitle → Developer / Analyst / Manager
            String personName = parts[1];          // Depois → nome. Exemplo: "Developer Alice" → ["Developer", "Alice"].  personName → nome da pessoa


            // Decidindo qual objeto criar:
            if (jobTitle.equals("Developer")) {                  // se o JobTitle da entrada por Developer, 
                consultantList.add(new Developer(personName));   // ele cria um Developer com esse nome (personName) da entrada e adiciona na lista 
            } else if (jobTitle.equals("Analyst")) {             // a lista não sabe qual é a classe concreta, ela só sabe que é tudo Consultant
                consultantList.add(new Analyst(personName));
            } else if (jobTitle.equals("Manager")) {
                consultantList.add(new Manager(personName));
            }
        }

        // Impressão final (polimorfismo)
        for (Consultant consultant : consultantList) {    // Percorre a lista de consultores
            System.out.println(consultant.present());     // chama o método present, cada objeto responderá corretamente. Developer → Dev: nome
        }
    }
}
